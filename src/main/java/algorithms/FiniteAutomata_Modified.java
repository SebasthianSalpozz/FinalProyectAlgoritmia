package algorithms;

import java.util.*;

/**
 * This class implements a modified Finite Automata algorithm to match patterns in strings.
 */
public class FiniteAutomata_Modified {

    /**
     * Matches a pattern against a complete text using a modified Finite Automata algorithm.
     * @param completeTxt The complete text to search for a pattern.
     * @param patternTxt The pattern to match in the complete text.
     * @return True if the pattern is found in the complete text, false otherwise.
     */
    public boolean match(String completeTxt, String patternTxt){
        List<String> pattern = splitString(patternTxt);
        Map<String, Integer>[] table = new Map[pattern.size()+1];
        setInitialData(table, pattern);
        fillTable(table, getLetters(splitString(completeTxt)), pattern);

        return searchMatch(splitString(completeTxt), table, pattern.size());
    }

    /**
     * Searches for a pattern match in a list of letters using the table generated by the Finite Automata algorithm.
     * @param lettersList The list of letters representing the complete text.
     * @param table The table generated by the Finite Automata algorithm.
     * @param patternLength The length of the pattern.
     * @return True if the pattern is found in the letters list, false otherwise.
     */
    public boolean searchMatch(List<String> lettersList, Map<String, Integer>[] table, int patternLength){
        int auxValue;
        int key = 0;
        for (String letter : lettersList){
            auxValue = table[key].get(letter);
            key = auxValue;
            if(auxValue == patternLength){
                return true;
            }
        }
        return false;
    }

    /**
     * Calculates the length of the longest prefix of the pattern that is also a suffix of the sub-pattern.
     * @param pattern The complete pattern.
     * @param subPattern The sub-pattern to compare.
     * @param plus The additional character to add to the sub-pattern.
     * @return The length of the longest prefix.
     */
    public int getLongestPrefix(List<String> pattern, List<String> subPattern, String plus){
        List<String> auxSubPattern = new ArrayList<>(subPattern);
        auxSubPattern.add(plus);
        List<String> auxComparator;

        int index = auxSubPattern.size() <= pattern.size() ?  0 :  1;;

        for (int i = index; i < auxSubPattern.size(); i++) {
            auxComparator = auxSubPattern.subList(i, auxSubPattern.size());
            if (auxComparator.equals(pattern.subList(0, auxComparator.size()))) {
                return auxComparator.size();
            }
        }

        return 0;
    }

    /**
     * Initializes the table with the initial data based on the pattern.
     * @param table The table to initialize.
     * @param values The values of the pattern.
     */
    public void setInitialData(Map<String, Integer>[] table, List<String> values){
        int index = 0;
        for (String letter : values){
            table[index] = new HashMap<>();
            table[index].put(letter, index + 1);
            index++;
        }
        table[index] = new HashMap<>();
    }

    /**
     * Fills the table with data based on the pattern and complete text.
     * @param table The table to fill.
     * @param values The values of the complete text.
     * @param pattern The pattern to match.
     */
    public void fillTable(Map<String, Integer>[] table, List<String> values, List<String> pattern){
        List<String> emptyList = new ArrayList<>();
        for (String value : values){
            if (table[0].get(value) == null){
                table[0].put(value, getLongestPrefix(pattern, emptyList, value));
            }
        }
        int index = 1;
        for (int i = 0; i < pattern.size(); i++){
            for (String value : values){
                if (table[index].get(value) == null){
                    table[index].put(value, getLongestPrefix(pattern, pattern.subList(0, i+1), value));
                }
            }
            index++;
        }
    }

    /**
     * Splits a string into a list of characters.
     * @param string The string to split.
     * @return A list of characters.
     */
    public List<String> splitString(String string) {
        //string = string.replaceAll(" ", "");
        String[] list = string.split("");
        return Arrays.asList(list);
    }

    /**
     * Extracts unique letters from a list of strings.
     * @param string The list of strings.
     * @return A list of unique letters.
     */
    public List<String> getLetters(List<String> string){
        Set<String> letters = new HashSet<>(string);
        return new ArrayList<>(letters);
    }


}
